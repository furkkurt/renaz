// Client-side script for comments page
import { getComments, addComment, addReply, type Comment } from './comments-client';

interface CommentType {
	id: string;
	name: string | null;
	service: string;
	comment: string;
	date: string;
	replies: CommentType[];
}

const COMMENTS_PER_PAGE = 20;
let allComments: CommentType[] = [];

// Format date
function formatDate(dateString: string): string {
	const date = new Date(dateString);
	return date.toLocaleDateString('tr-TR', {
		year: 'numeric',
		month: 'long',
		day: 'numeric',
		hour: '2-digit',
		minute: '2-digit'
	});
}

// Render comment
function renderComment(comment: CommentType, isReply: boolean = false): string {
	const name = comment.name || 'İsimsiz';
	const indentClass = isReply ? 'reply-item pl-6' : '';
	
	let html = `
		<div class="comment-item ${indentClass} bg-white p-6 rounded-lg shadow-md mb-4">
			<div class="flex justify-between items-start mb-3">
				<div>
					<h3 class="text-lg font-bold text-[#000000]" style="font-family: 'Roboto Condensed', sans-serif;">
						${name}
					</h3>
					<p class="text-sm text-gray-600" style="font-family: 'Roboto Condensed', sans-serif;">
						${comment.service}
					</p>
				</div>
				<span class="text-sm text-gray-500" style="font-family: 'Roboto Condensed', sans-serif;">
					${formatDate(comment.date)}
				</span>
			</div>
			<p class="text-[#000000] leading-relaxed mb-3" style="font-family: 'Roboto Condensed', sans-serif;">
				${comment.comment.replace(/\n/g, '<br>')}
			</p>
			${!isReply ? `
				<button
					onclick="showReplyForm('${comment.id}')"
					class="text-sm text-[#fad000] hover:text-[#e6c200] font-medium"
					style="font-family: 'Roboto Condensed', sans-serif;"
				>
					Yanıtla
				</button>
				<div id="reply-form-${comment.id}" class="hidden mt-4 pt-4 border-t border-gray-200">
					<form onsubmit="handleReply(event, '${comment.id}')" class="space-y-3">
						<input
							type="text"
							id="reply-name-${comment.id}"
							placeholder="İsim (İsteğe Bağlı)"
							class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#fad000] focus:border-[#fad000] outline-none text-sm"
						/>
						<textarea
							id="reply-comment-${comment.id}"
							required
							rows="3"
							placeholder="Yanıtınızı yazın..."
							class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#fad000] focus:border-[#fad000] outline-none resize-none text-sm"
						></textarea>
						<div class="flex space-x-2">
							<button
								type="submit"
								class="bg-[#fad000] text-[#000000] font-bold py-2 px-4 rounded-lg hover:bg-[#e6c200] transition-colors duration-200 text-sm uppercase"
								style="font-family: 'Roboto Condensed', sans-serif;"
							>
								Gönder
							</button>
							<button
								type="button"
								onclick="hideReplyForm('${comment.id}')"
								class="bg-gray-200 text-[#000000] font-bold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors duration-200 text-sm"
								style="font-family: 'Roboto Condensed', sans-serif;"
							>
								İptal
							</button>
						</div>
					</form>
				</div>
			` : ''}
		</div>
	`;
	
	// Render replies
	if (comment.replies && comment.replies.length > 0) {
		html += comment.replies.map(reply => renderComment(reply, true)).join('');
	}
	
	return html;
}

// Load comments from Firestore
async function loadComments(): Promise<void> {
	try {
		allComments = await getComments();
		displayComments(1);
	} catch (error) {
		console.error('Error loading comments:', error);
		const container = document.getElementById('comments-container');
		if (container) {
			container.innerHTML = `
				<div class="bg-white p-8 rounded-lg shadow-md">
					<p class="text-lg text-[#000000] text-center text-red-600" style="font-family: 'Roboto Condensed', sans-serif;">
						Yorumlar yüklenirken bir hata oluştu. Lütfen sayfayı yenileyin.
					</p>
				</div>
			`;
		}
	}
}

// Display comments with pagination
function displayComments(page: number = 1): void {
	const container = document.getElementById('comments-container');
	const paginationContainer = document.getElementById('pagination-container');
	
	if (!container) return;
	
	// Sort by date (newest first)
	const sortedComments = [...allComments].sort((a, b) => 
		new Date(b.date).getTime() - new Date(a.date).getTime()
	);
	
	const totalPages = Math.ceil(sortedComments.length / COMMENTS_PER_PAGE);
	const startIndex = (page - 1) * COMMENTS_PER_PAGE;
	const endIndex = startIndex + COMMENTS_PER_PAGE;
	const pageComments = sortedComments.slice(startIndex, endIndex);
	
	if (pageComments.length === 0) {
		container.innerHTML = `
			<div class="bg-white p-8 rounded-lg shadow-md">
				<p class="text-lg text-[#000000] text-center" style="font-family: 'Roboto Condensed', sans-serif;">
					Henüz yorum yapılmamış. İlk yorumu siz yapın!
				</p>
			</div>
		`;
		if (paginationContainer) paginationContainer.classList.add('hidden');
		return;
	}
	
	container.innerHTML = pageComments.map(comment => renderComment(comment)).join('');
	
	// Render pagination
	if (totalPages > 1 && paginationContainer) {
		paginationContainer.classList.remove('hidden');
		let paginationHTML = '';
		
		if (page > 1) {
			paginationHTML += `
				<button
					onclick="displayComments(${page - 1})"
					class="px-4 py-2 bg-[#fad000] text-[#000000] font-bold rounded-lg hover:bg-[#e6c200] transition-colors duration-200"
					style="font-family: 'Roboto Condensed', sans-serif;"
				>
					Önceki
				</button>
			`;
		}
		
		for (let i = 1; i <= totalPages; i++) {
			if (i === page) {
				paginationHTML += `
					<span class="px-4 py-2 bg-[#000000] text-[#fad000] font-bold rounded-lg" style="font-family: 'Roboto Condensed', sans-serif;">
						${i}
					</span>
				`;
			} else if (i === 1 || i === totalPages || (i >= page - 2 && i <= page + 2)) {
				paginationHTML += `
					<button
						onclick="displayComments(${i})"
						class="px-4 py-2 bg-gray-200 text-[#000000] font-bold rounded-lg hover:bg-gray-300 transition-colors duration-200"
						style="font-family: 'Roboto Condensed', sans-serif;"
					>
						${i}
					</button>
				`;
			} else if (i === page - 3 || i === page + 3) {
				paginationHTML += `<span class="px-2">...</span>`;
			}
		}
		
		if (page < totalPages) {
			paginationHTML += `
				<button
					onclick="displayComments(${page + 1})"
					class="px-4 py-2 bg-[#fad000] text-[#000000] font-bold rounded-lg hover:bg-[#e6c200] transition-colors duration-200"
					style="font-family: 'Roboto Condensed', sans-serif;"
				>
					Sonraki
				</button>
			`;
		}
		
		paginationContainer.innerHTML = paginationHTML;
	} else if (paginationContainer) {
		paginationContainer.classList.add('hidden');
	}
}

// Handle comment form submission
async function handleCommentSubmit(event: Event): Promise<void> {
	event.preventDefault();
	
	const form = event.target as HTMLFormElement;
	const formData = new FormData(form);
	
	const name = (formData.get('name') as string)?.trim() || null;
	const service = formData.get('service') as string;
	const comment = (formData.get('comment') as string)?.trim();
	
	if (!service || !comment) {
		alert('Lütfen tüm gerekli alanları doldurun.');
		return;
	}
	
	// Show loading state
	const submitButton = form.querySelector('button[type="submit"]') as HTMLButtonElement;
	if (submitButton) {
		submitButton.disabled = true;
		submitButton.textContent = 'Gönderiliyor...';
	}
	
	try {
		const commentId = await addComment({
			name,
			service,
			comment,
			replies: []
		});
		
		if (commentId) {
			form.reset();
			await loadComments(); // Reload comments from Firestore
			
			// Scroll to top of comments
			const container = document.getElementById('comments-container');
			if (container) {
				container.scrollIntoView({ behavior: 'smooth', block: 'start' });
			}
		} else {
			alert('Yorum gönderilirken bir hata oluştu. Lütfen tekrar deneyin.');
		}
	} catch (error) {
		console.error('Error submitting comment:', error);
		alert('Yorum gönderilirken bir hata oluştu. Lütfen tekrar deneyin.');
	} finally {
		if (submitButton) {
			submitButton.disabled = false;
			submitButton.textContent = 'Yorumu Gönder';
		}
	}
}

// Handle reply form submission
async function handleReply(event: Event, parentId: string): Promise<void> {
	event.preventDefault();
	
	const form = event.target as HTMLFormElement;
	const nameInput = document.getElementById(`reply-name-${parentId}`) as HTMLInputElement;
	const commentInput = document.getElementById(`reply-comment-${parentId}`) as HTMLTextAreaElement;
	
	const name = nameInput.value.trim() || null;
	const comment = commentInput.value.trim();
	
	if (!comment) {
		alert('Lütfen yanıtınızı yazın.');
		return;
	}
	
	// Show loading state
	const submitButton = form.querySelector('button[type="submit"]') as HTMLButtonElement;
	if (submitButton) {
		submitButton.disabled = true;
		submitButton.textContent = 'Gönderiliyor...';
	}
	
	try {
		const success = await addReply(parentId, {
			name,
			service: 'Yanıt',
			comment,
			replies: []
		});
		
		if (success) {
			form.reset();
			hideReplyForm(parentId);
			await loadComments(); // Reload comments from Firestore
		} else {
			alert('Yanıt gönderilirken bir hata oluştu. Lütfen tekrar deneyin.');
		}
	} catch (error) {
		console.error('Error submitting reply:', error);
		alert('Yanıt gönderilirken bir hata oluştu. Lütfen tekrar deneyin.');
	} finally {
		if (submitButton) {
			submitButton.disabled = false;
			submitButton.textContent = 'Gönder';
		}
	}
}

// Show reply form
function showReplyForm(commentId: string): void {
	const form = document.getElementById(`reply-form-${commentId}`);
	if (form) {
		form.classList.remove('hidden');
	}
}

// Hide reply form
function hideReplyForm(commentId: string): void {
	const form = document.getElementById(`reply-form-${commentId}`);
	if (form) {
		form.classList.add('hidden');
		const nameInput = document.getElementById(`reply-name-${commentId}`) as HTMLInputElement;
		const commentInput = document.getElementById(`reply-comment-${commentId}`) as HTMLTextAreaElement;
		if (nameInput) nameInput.value = '';
		if (commentInput) commentInput.value = '';
	}
}

// Make functions globally available
(window as any).displayComments = displayComments;
(window as any).handleReply = handleReply;
(window as any).showReplyForm = showReplyForm;
(window as any).hideReplyForm = hideReplyForm;

// Initialize parallax
function initParallax() {
	const parallaxElements = document.querySelectorAll('.parallax-bg');
	if (parallaxElements.length === 0) return;

	function updateParallax() {
		const scrollY = window.pageYOffset || window.scrollY || document.documentElement.scrollTop;
		const scrollFactor = 0.25;

		parallaxElements.forEach((element) => {
			const htmlElement = element as HTMLElement;
			const wrapper = htmlElement.closest('.tiled-background-wrapper') as HTMLElement;
			if (!wrapper) return;

			const offsetY = scrollY * scrollFactor;
			const tileSize = 200;
			const normalizedOffset = offsetY % tileSize;
			
			htmlElement.style.backgroundPosition = `0 ${normalizedOffset}px`;
		});
	}

	let ticking = false;
	function onScroll() {
		if (!ticking) {
			window.requestAnimationFrame(() => {
				updateParallax();
				ticking = false;
			});
			ticking = true;
		}
	}

	updateParallax();
	window.addEventListener('scroll', onScroll, { passive: true });
	window.addEventListener('resize', updateParallax);

	return () => {
		window.removeEventListener('scroll', onScroll);
		window.removeEventListener('resize', updateParallax);
	};
}

// Initialize
document.addEventListener('DOMContentLoaded', async () => {
	initParallax();
	
	const form = document.getElementById('comment-form');
	if (form) {
		form.addEventListener('submit', handleCommentSubmit);
	}
	
	// Load comments from Firestore
	await loadComments();
});

